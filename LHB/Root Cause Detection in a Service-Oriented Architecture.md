Root Cause Detection in a Service-Oriented Architecture

论文阅读整理与归纳

这篇论文想要解决的问题是：在面向服务的体系结构中，如何利用前端出现的异常进行搜索，找到异常出现的根因。

为了更进一步定义问题，文章首先们总结了可用于诊断的数据。 单个传 感器发出具有唯一通用标识符的度量数据(例如延迟、错误计 数和吞吐量。 此标识符是在接收用户请求的第一前端服务中生成的，然后传播到下游的callee服务。 这些度量数据被收集并存储在一个合并的位置，以便通过加入通用标识符来创建完整的调用图。调用图是一个有向图，vi->vj代表i调用j。需要注意的是，传感器之间类似的异常行为可能与它们在调用图中的关系无关。

解决方案：

![截屏2021-10-20 下午9.39.04.png](https://img-youpai.weixiaoi.com/tu/2021/1020/1634744565211020.png)

首先，度量收集系统接收和聚合来自所有传感器的度量， 

最后将它们存储到一个时间分区数据库中。

批处理模式引擎生成调用图并提取外部因素。 此输出存储回另一个数据库。 （外部因素是通过伪异常聚类算法提取的）

实时引擎然后从两个数据库加载必要的数据，并提供根原因传感器的排序列表。 使用这些数据，实时引擎执行随机游走算法。

伪异常聚类算法：基于历史度量相关性将传感器分组在一起，捕获外部因素导致的相关。

检测到的异常不一定只捕获真实报告的异常，我们将它们称为伪异常

伪异常聚类算法：

如果传感器受到相同的外部因素的影响，它们在种子传感器上的模式相似度得分会比较接近和高;否则，不属于给定集群的传感器表现出较低的模式相似性得分。这些假设简化了现实世界，但是当我们重新查看图3(b)时是有意义的。我们忽略中心的聚类，因为它表示每个传感器和前端一个传感器之间的相似度很低(即混合了随机效应)。剩下的两个区域(矩形和椭球)符合我们的假设，因为与给定伪异常无关的传感器代表了小的模式相似性分数。在这些区域的相关传感器之间也显示出很高的相似分数。在实践中，其他传感器组合也观察到这种现象，从而验证了我们的假设。算法的细节。现在我们详细描述伪异常聚类算法。聚类算法的输入是(a)一个种子前端传感器vfe(即v1)， (b)来自历史数据(t1，···，tk)的各种伪异常矩，(c)传感器模式相似度评分(S(t1)，···，S(tk))。历史数据被限制到最近几周，因此限制了要处理的数据量。过滤掉所有服务模式相似度得分较低的伪异常矩。这种方法可以去除检测算法产生的假阳性矩。然后，我们捕获关于每个清理伪异常矩的高模式相似分数的传感器。利用(1)中的假设，我们根据传感器的模式相似度评分将传感器(除前端传感器外)分为两组。其中一组传感器代表低模式相似度(接近于零)，另一组传感器代表高模式相似度(接近于第(1)中的μ (t))。对于给定的伪异常矩，我们将后一组称为簇。最后，我们使这个聚类稀疏，以保持在一定的外部因素下仅关键传感器。

实时引擎：一个简单的用 户界面允许他们输入一个前端传感器，一个度量，以及与观 察到的异常对应的时间段。 结果是一个有序的根原因传感器 列表。 用户界面的交互性质允许团队不断地改变他们的输 入，同时在接近实时的情况下返回诊断指南。

如果两个服务在某一度量中具有相似的异常模式，我们可以想象这些 模式可能是由相同的根本原因引起的。 特别是，当相同的异常引起变化时，两个传感器的度量数据可以看起来相似，而不管数据在正常情况下是否看起来相似。

实时引擎结合度量模式相似性评分和调用图两个因素来进行根因检测。

基本思想是根据相似分对调用图进行随机游走。 更具体地说，通过在调用图中的邻居中随机拾取下一个传感器，依次选择传感器。 每个邻居的拾取概率与其与给定异常的相关性成正比，该异常由模式相似性评分捕获。

