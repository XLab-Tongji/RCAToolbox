# Trace-based Intelligent Fault Diagnosis for Microservices with Deep Learning

### 追踪模型：

#### 有向加权图（RWDG）：

顶点包含细节：*Si = (ServiceName, spansNum, status, details)*（微服务名、调用次数、微服务是否返回错误相应代码、*details={si, s2, ... ,sn*}记录了Si每次被调用的细节

*si = (startTime, duration, statusCode, callerName)*（被调用微服务的时间戳、执行微服务所消耗的时间、响应的HTTP状态码（不存在设为0）、调用者微服务名称）

有向边的权值表示服务响应所消耗的时间。

#### 构造RSS字符串：

![截屏2021-11-07 下午3.39.01](/Users/liuhongbo/Library/Application Support/typora-user-images/截屏2021-11-07 下午3.39.01.png)

在这个例子中，微服务A首先调用微服务B来处理请求，微服务B继续依次调用微服务E和F。然后，微服务A调用微服务C，后者调用微服务F来处理请求。最后，微服务A调用微服务D，后者再次调用微服务F进行处理。相同的微服务名称代表相同的微服务。我们使用固定哈希函数将微服务的名称映射到反映微服务的固定长度字符串。然后根据生成调用的时间顺序(如图中标记的顺序)将所有字符串依次拼接在一起。结果字符串反映了跟踪中微服务调用的顺序。

#### 异常检测模型：

RWDG模型关注微服务响应时间，这是我们检测微服务性能异常的一个重要指标。接下来，我们将描述rwdg在检测微服务性能异常方面的作用。
在RWDG中，由于网络延迟等随机因素，顶点间相同类型请求的响应时间接近正态分布。因此，我们可以设置一个间隔，以便将超出该间隔的响应时间视为异常。因此，我们以正常跟踪日志生成的所有rwdg为例，计算请求的正常响应间隔的边界:![截屏2021-11-07 下午3.45.42](/Users/liuhongbo/Library/Application Support/typora-user-images/截屏2021-11-07 下午3.45.42.png)

![IMG_1684](/Users/liuhongbo/Downloads/IMG_1684.JPG)

#### 检查微服务是否存在性能异常的算法思想：

##### 1.使用RWDG：

a)对于当前请求对应的RWDG Du，检索起始时间最早的顶点S1作为起始顶点，表示当前请求中调用的第一个微服务。然后，我们使用哈希函数将顶点S1的服务名N1转换为固定长度的字符串C1。
b)获取这个顶点和下一个顶点S2之间的有向边的权值dt1。
c)根据调用关系走到下一个顶点S2。然后，使用与步骤(1)相同的映射函数，将顶点S2的服务名N2转换为定长字符串C2。
d)查询第一个有向边在C1和C2之间的正常权值区间。如果dt1在正常区间内，则判断S1到S2的调用为正常调用，以顶点S2为当前顶点;否则，该调用为异常调用。
e)对每个顶点T重复步骤(a)、(b)、(c)和(d)，直到检测完当前请求的每个调用。如果有异常，返回RWDG状态（status）为1;否则,返回0。

##### 2.使用RSS:

a)对于当前请求，在Trace日志中检索没有父span的span作为第一个span S，这表示当前请求中调用的第一个微服务，请求作为启动服务发出。然后，我们使用哈希函数将调用者微服务S1的服务名N1转换为一个固定长度的字符串C1
b)得到微服务S1调用的微服务S2。然后，使用与步骤(1)相同的映射函数将服务S2的服务名N2转换为固定长度的字符串C2。
c)根据依赖关系继续寻找下一个span，取下一个span为S。
d)重复步骤(a)、(b)和(c)，直到检测到当前请求的所有范围。计算所有正常的rss的最小编辑距离d，并返回d。

```
function Judgement(Du)#计算最小编辑距离
 Cr,Ck,C1,C2<-""
 s<-Tr.root
 S1,S2<-null
 d<-Max_Int
 while s.next is not null do
  S1<-s.GetCaller()
  S2<s.GetCalled()
  C1<-Hash(S1.name)
  C2<-Hash(S2.name)
  Cr<-Cr+C1+C2
  s<-s.next
 end while
 #计算当前请求生成的RSS与所有正常RSS之间的最小编辑距离作为返回值。
 for Ck in C do
  if EditDis(Ck,C)<d:
   d<-EditDis(Ck,C)
   end if
 end for
 return d
end function
```

如果d的值为0，则RSS没有异常;如果d大于0，则RSS中存在工作流异常。

异常评价指标：
$$
e_w=d/l_c
$$
（到这里，我们已经知道了如何判断一个请求发出后是否出现异常，并获得了一些参数，接下来我们通过训练模型，来实现预测具体发生的是什么异常，以及是由谁引起的）

#### 使用DNN进行故障定位（根因分析模型）：

设计输入向量：
$$
X=(E,status,e_c,S,l_C,e_w)
$$
E:RWDG的邻接矩阵，每个元素tmn表示从编号为m的微服务调用到编号为n的微服务的平均响应时间。由于输入向量的约束，我们将行向量拆分并顺序组合。

status:对应RWDG中是否有异常的标识符，取值为0或1。

ec:请求报文中是否包含HTTP错误字段，如果存在HTTP错误则设置为1，反之亦然。

S：调用次数矩阵。spq代表微服务p发起的对微服务q调用的子串在相应的RSS中出现的次数。（将矩阵S拆分为行向量）

![截屏2021-11-07 下午6.26.53](/Users/liuhongbo/Desktop/截屏2021-11-07 下午6.26.53.png)

lc:对应RSS的长度

ew:工作流异常度，取值范围为[0,1]

将E，S，lc进行了归一化：

![截屏2021-11-07 下午6.43.03](/Users/liuhongbo/Library/Application Support/typora-user-images/截屏2021-11-07 下午6.43.03.png)

使E，S，lc内的值取值范围都为0-1.

模型输出向量Y：代表根因最可能在的微服务集合。

#### 训练模型：

使用DNN实现分类器模型。

（通过前馈过程计算和发现输出网络的计算故障，然后，通过反向传播过程使用梯度下降优化神经网络的权值。经过多次调整后，DNNs模型能够有效地反映出受故障影响的微服务与轨迹模型之间的非线性映射关系。）

采用基于反向传播算法的DNNs模型进行故障定位。前馈传递过程采用Adam算法。Adam算法可以通过校正梯度的指数移动平均和平方梯度来保持每个参数的学习率。

激活函数：

![截屏2021-11-07 下午7.31.10](/Users/liuhongbo/Library/Application Support/typora-user-images/截屏2021-11-07 下午7.31.10.png)

使用标签的方法：

1.当微服务应用程序中的注入故障的影响是微服务响应时间的大幅波动时，所有涉及该服务的请求都被标记为有异常。故障请求的输出值为受影响的微服务，其余为“No fault”。

2.当微服务应用中注入故障的影响是微服务请求处理顺序的改变时，所有包含改变部分的请求都被标记为异常。故障请求的输出值为受影响的微服务，其余为“No fault”。

当出现未知故障时，使用标签给用户提供有用的参考。



