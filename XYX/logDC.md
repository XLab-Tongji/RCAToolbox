# logDC

**声明性部署**啥意思

## 1. introduction

1. 主流云平台声称可以提供自动化、可伸缩性、敏捷性和易于使用，以实现应用程序的业务目标。为了利用这些云功能，开发人员需要描述所需的应用程序结构和状态
2. 管理和操作这样的云操作会从声明式部署中获得额外的复杂性；在开发阶段编码较少通常意味着在运行阶段会出现更多的麻烦；由于更加分布式和复杂，使得我们很难找到云中失败的根本原因，因为很多动态因素会掩盖掉真正的原因
3. **使用历史日志生成一个操作的特定形式来建造一个“相关模型”来代表正常操作，当系统出错时，操作人员就可以将收集到的失败操作和“相关模型”对比，基于当前日志与“相关模型”的偏差推断问题所在**
4. 尽管已经有很多研究了，但是还是需要不停的适应不断变换的云平台：
   1. 云平台从资源导向变为应用导向，**不能设计专门为一个应用程序服务的日志参照模型，而应该去推广构造日志参照模型的方法**（授人以鱼不如授人以渔）
   2. 应用程序的行为具有更多的多样性和动态性，日志参考模型必须有效捕获这些行为，并且要拓展到应用程序的整个生命周期。
5. 所以，方法和系统要重新设计，LogDC的动机是在分布式应用程序之前繁琐和困难的故障排除过程中提供直观的“比较和发现”经验。
6. 参考模型低触摸，机器学习多方面利用
7. 作用：
   1. 为一类应用程序构建参考模型
   2. 通过应用程序的生命周期来识别正常的行为
8. 应用分类：构造新方法（没说先）设计了从应用程序的部署声明中提取特征的新方法，并基于其训练分类器。
9. 模型构造：基于在一个稳定的云平台中，大多数部署的工作负载都处于它们所期望的状态为前提，并基于聚类算法收集正常的样本
10. 然后拿实例测了测真的可行，还很好，各个方面的错误都能检测到

## 2.相关工作

3种模型：基于日志数量的模型，基于模板数量的模型，基于状态转换的模式

- 基于日志数量的模型：计算日志数量，突然增多代表错误，适用于线上场景，太直接了不适用于复杂的云架构
- 基于模板数量的模型：通常计算一个时间窗口中不同模板的数量，并为每个时间窗口设置一个向量。然后利用机器学习算法等方法来区分异常值，实现简单但不能为问题识别和诊断提供帮助
- 状态过渡模型：就是上文所描述的本文的方法

优点：

- 它可以诊断深深隐藏在日志序列中的问题
- 可以为工程师提供有关问题的上下文日志消息
- 它可以为工程师提供正确的日志序列，并告诉工程师应该发生了什么

对于日志问题识别，之前提出过很多方法，所有方法都没有采用部署信息来帮助问题诊断。

## 3.背景与概述

声明式部署的元素，K8s基本框架，LogDC的框架

### A.声明是部署

声明式部署利用结构模型来描述由部署引擎强制执行的所需的应用程序结构和状态。它定义了一个首要的云部署配置（使用了那些图像，网络如何搭建），而且，应用的行为被许多环境变量和附加的政策所调和。所以**一个应用的部署文件有着固定的特征，一个应用包含了许多软件属性，所以一个应用架构是多个架构的整合**，在K8s里所有这些都会被**独立**处理，所以我们可以只拿一个单一的部署来调查他的特征。



### B.K8s的应用生命周期

一个应用自被创造开始就不停的产生日志，图2，**状态1**多个K8s组件协作完成操作时，生成的日志数量会增加。**状态2**在普通运行状态时，日志数量并不多。

**我们就是从这2个状态捕获日志**



### C. LogDC的组件和进程

LogDC包括五个模块，数据爬虫、部署分类、模型构建器、日志处理和异常定位。数据爬虫负责收集历史部署yaml文件和运行时日志。使用收集到的部署yaml文件，部署分类模块提取这些部署的文本特性，并为每种类型的部署构建一个分类模型。同时，日志处理模块编织由不同K8S组件生成的日志条目，构建日志模板，并提取日志特征。给定日志特性和声明类，模型构建器将为每一类部署训练一个参考模型。然后，异常定位模块用相应的参考模型对新收集的对数数据进行异常定位。最终的输出是可疑的声明性原语或日志项。



## 4.部署分类

### A.部署收集和过滤

爬虫--->内部系统和github(这里用关键字 “replicas or deployment ”和拓展字“yaml”爬)

这里举了个例子

从一个人的代码存储库中，找到一个jenkins-deployment.yaml。但是，并非所有的部署文件都能成功地部署。因此，他们手动过滤掉带有显式错误的部署，如缺乏关键配置和语法错误。之后，他们用其部署名称来标记部署，这是yaml文件中的一个配置项。**值得注意的是，同一应用程序的不同版本可能会用不同的名称进行标记。**（这是一个缺陷吗？？？没懂）

### B.部署分类

训练部分包含离线训练部分和在线检测部分：

离线训练部分：在相关的部署中提取文本特征，使用一种朴素的贝叶斯方法对这些部署进行分类；结果：一组类，每一个类都是一个朴素贝叶斯模型

在线监测部分：依据训练好的模型对异常部署进行分类；结果：部署标签（就是所属的错误）

**如何提取特征：**

1. 使用NLTK（自然语言Tookit）提供的api对文本文档进行标记化。（NLTK是一个自然语言库，具有一系列文本处理功能，如标记化、标记、标记、解析等。）
2. 每个标记被转换成小写字母
3. 过滤掉无意义的标记（如终止字，标点符号）和预定义的标记（如api版本），然后每个标记都是这段文本的特征。
4. 将这些标记就放进朴素贝叶斯模型训练器训练（这里选择了朴素贝叶斯分类器，因为文本特征相互独立，它只需要少量的训练数据来估计参数进行必要的分类。）
4. 当遇到异常时，提取他的文本特征并投放给朴素贝叶斯分类器，这个分类器就会返回最大可能的部署类（注意：当最大可能的部署类的可能性都小于临界值0.05时，我们认为时一个新的异常），只有当操作员解决了这个问题，才会重新添加到特征类库中。

## 5.正常模块建模

### A.日志编制

与一个部署相关的日志分布在不同的节点上，因此，为了为一个部署的整个生命周期构造一个日志模型，需要编制由不同K8s组件构造的日志。K8s的对资源的部署伴随着UIDs和names的分配，我们就可以寻找这2个指标的重合部分（调用和被调用的关系）。图六就是一个流程样例。

### B.特征提取

一个日志条目包括日志等级，时间戳，线程ID，资源文件，信息主体。但这里**只利用信息主体来构建正常的模型和诊断根本原因**，其他都不要（改进方向？）一个操作有很多变量，但他们都没用，我们要提取不变量。

这里他们用了一个之前的模板挖掘工具，挖掘好后变量被掩盖。

**将K8s组件的名字和模板作为特征**，LogDC维护着一个特征库

每个部署最后变为一个特征向量，有0,1组成，代表有没有一个特征。

然后根据这些特征向量来训练正常状态下的模型。

### C.模型建造

K8s里存在大量来源于同一个应用的部署。收集这些部署和相关日志，分别建造模型。

问题1：我们不知道一个部署是否正常，因为有些部署没有异常报告。

解决方法：模型构建方法可以同时利用正常部署和异常部署生成的日志。

- 利用K-means聚类算法分离正常和异常的部署
  - 将n个结果划分为K个簇，其中每个结果都属于具有最接近平均值的簇，作为簇的原型。
  - 给定一组观测值($x_1,x_2,x_3....x_m$),每个$x_i$代表一个部署的特征向量，K-means就将n个观测值划分为K个簇，即($C_1,C_2,....C_k$),从而最小化簇内的平方和。
  - 式子中，，$\mu_i$代表平均值，$Var(C_i)$代表方差
  - 这里只需要分离正常和异常部署，所以K设置为2.
  - ***因为大多数日志都是从正常部署中收集到的，所以可以认为部署数量较多的集群是正常部署，另一个集群是异常部署***
- 采用逻辑回归的方式学习正常和异常部署的模式

## 6.异常定位

异常定位过程由显式异常或系统管理员触发。

做了实验，消失的和隐藏的异常都能被检测出来

## 7.实验验证

## 8.总结

**这里说通过在参考模型的构建和匹配阶段减少对日志条目的时间顺序的依赖性，LogDC能够诊断应用程序的整个生命周期中的问题**

未来改进：

多个故障同时发生

部署分类的优化

异常定位的优化

