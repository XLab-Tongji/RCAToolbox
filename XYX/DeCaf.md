# DeCaf：自动诊断和分类的通用系统

- ？？end-end system？？

- 本文中 断言 和 谓词 是同一个单词 predicates

## 摘要

大型云服务一般用（Key Performance Indicators）KPIs来跟踪和监控性能，通常将（Service Level Objectives ）SLOs内嵌到与KPI绑定的客户协议中。

在诊断和分析错误时，要尽量减少时间和人工工作；但日志中大量的混合属性让诊断并不简单。

本文构建和部署了叫DeCaf的系统，这个系统可以通过使用服务的日志来自动诊断和分类KPIs。

使用**机器学习和模块挖掘**自动定位根因和分诊性能的问题。

## 1.介绍

引入DevOps：服务者负责和满足关键绩效指标（KPIs）上的服务级别目标（SLOs）

DeCaf：

1. 能够大量节省时间，减少人工
2. 能处理大容量和大量数据的日志，以及不同种类的KPIs
3. 建立了长期的结果的库，并可以自动对新发现的问题进行分类（有点像之前的LogDC）

在第2节中，我们将讨论在大规模服务中诊断和分类性能问题时所面临的挑战

在第3节中，我们将讨论相关的工作

**在第4节中，提供了对DeCaf系统的概述**

**在第5节中，我们将详细描述我们的方法**

在第6节中，我们将描述实现的细节

在第7节中，我们将介绍微软中2个大规模云服务的案例研究结果

在第8节中，我们对DeCaf的准确性和运行时性能进行了实验评估

在第9节中，讨论其适用性以及未来的工作

在第10节中，进行了总结

## 4.概述

原则：使用简单的可解释的技术构建一个通用系统，方便服务所有者可以自己拥有和部署DeCaf。

- Orion：一种无状态的路由服务，它将请求传递到正确的后端或者mailbox server (the one hosting the user’s active mailbox database)，请求延时是Orion的一个重要指标，将会影响到所有客户端。
- Domino

目标：构建一个系统能自动帮助DevOps工程师将性能回归缩小到请求子集；对于每一个已确定的问题，都会输出一个根本原因，其中包含一组断言，影响度量，分类类别。断言有助于江回归缩小到日志行和列的子集，然后可以进一步用于缓解问题。断言是一个boolean类型的函数

**DeCaf的输出结果：**

- 相关断言：预测指标与绩效回归相关。
- 范围：定义回归范围的预测值。
- 采样数据中受影响的请求的计数
- 对KPI的影响
- 分类结果r:$ r ∈ \{new, existing, regressed, improved, resolved\}$

1个例子：

• **Correlated predicate**（相关断言）: Rack:AN150C01

• **Scope predicates**（范围）: {RequestType:Offbox ∧ LocDataCenter:AN∧ CrossDataCenter:true}

• **Requests impacted**（受影响的请求数）: ~1 Billion

• **Latency impact**（延迟影响）: 4419ms

• **Triage result（分类结果）**: new



## 5.详细描述

1. 从原始服务日志中进行数据准备工作
2. ML模型的训练
3. 从学习到的模型中提取规则
4. 基于历史数据的问题分类

### 1）数据准备

- 数据预处理：日志分布在多个数据流，服务所有者会编写查询来聚合和连接来自各种流/源的数据。通常在编写日志时数据会被序列化，所以还将数据解序列化为结构化，并用("<EMPTY>")来代替空值。

- 特征选择：不是所有特征都对根因分析有用，例如一个ID，对根因分析完全没有用，而且如果考虑在内还会导致**状态爆炸**（state explosion.）

  - DeCaf将特征分为连续类型和分类类型，并测量分类变量的基数。以此提供了修剪高基数特征的建议
  - 服务拥有者根据上一步和自己的知识进一步修剪

- 分层：是将数据分为互斥，同类和集体的子集或者类的过程；虽然在分层中可能有多个类，但只考虑二进制类因为它支持我们在实践中遇到的对所有KPIs的诊断。将其分类：

  - 正面的：显示KPI的异常行为或违反性能SLO的请求
  - 负面的：符合KPI和SLO的请求（**正面和反面和我们正常的理解刚好相反**）

  分层标准有SLO确定，是DeCaf的输入

- 取样：有随机抽样、系统抽样、分层抽样、聚类抽样等，这里考虑**随机分层取样**

  - 类别不均衡：大多数服务大部分时间都是正常运行
  - 需要考虑全体数据，随机取样可以考虑到全体数据

	### 2）ML模型训练

使用ML模型来学习与性能问题相关的谓词。它是一种用于分类和回归的集成机器学习方法，通过构建大量的决策树来操作。

为了训练模型，我们使用KPI(延迟、失败)作为目标标签，而其余的日志属性作为特征或独立变量。

另外，与传统的机器学习不同，我们不使用经过训练的模型进行预测。DeCaf分析训练过的模型来提取可以帮助定位性能回归的断言。

- 决策树：决策树由一组分裂节点和叶节点组成，其中每个节点都由一个断言定义。本质上，决策树是节点层次结构。决策树可以同时用于分类目标变量和连续目标变量。如果目标变量是分类的，则使用分类树；如果它是连续的，则使用回归树。分类树和回归树都遵循相似的训练过程；在每一个训练步骤里，选择最佳的断言来对数据分区，重复。
- 分类树：分类树用于预测分类目标变量。在训练时，分类树通过减少分割后分割数据的熵来最大每次分割时的信息增益。
- 回归树：回归树用于预测连续的变量。与分类树不同，回归树不是最大化信息增益，而是最小化均方误差(MSE)。
- 模型输出：将二进制模型转储为基于文本的可读格式（没细说）。每棵树都包含一个从根节点到叶节点的分层分区断言列表。对于每个节点，计算了如下指标：
  - 行计数：一个节点中的训练样本的数。
  - 异常概率（分类树）：训练样本属于正（异常）类的概率。
  - 预测值（回归树）：一个节点中样本的目标变量的平均值。

### 3）规则提取

- 由2）得到了一堆树，从根节点开始遍历每棵树，每个节点计算左右子树的总分数，评分函数将由随机森林模型生成的度量作为参数。评分函数由服务所有者根据SLO定义。

- 对于树中的每个节点谓词，然后计算一个对性能产生影响的分数。它是左子节点和右子节点的得分之间的差异，即，当谓词为true和当它为frlse时：

  *CorrelationScore* = *Score*(*Le f tChild*) − *Score*(*RightChild*) 

​		如果相关性得分为正相关，则表示谓词(P：X→true)与性能下降呈正相关，否则则为负相关。

- 使用上述算法，从随机森林模型中提取一组规则；其中一个规则包括：(a)相关谓词：当前节点的谓词，(b)Scope谓词：来自父节点的谓词的逻辑连接，(c)相关性得分，(d)请求计数：受影响的请求的数量。
- 通过只保留每个相关谓词的影响得分最大的规则来删除重复的规则集。此外，基于来自服务所有者的反馈，删除了带有负相关谓词的规则，因为在根因分析中，服务团队认为它们没有用。

### 4）分类

- DeCaf算法的结果被上传到一个SQL数据库，利用历史记录，根据相关性谓词和相关性得分，将DeCaf生成的规则自动分为以下类别：

  - New 新的：提取了一个在过去14天内未出现过的新谓词。
  - Regressed 回归：谓词的得分比过去14天计算出的平均得分高出1个标准差以上。
  - Known 已知：得分与过去14天计算出的平均分在1个标准差以内。
  - Improved 改进：评分至少比过去14天计算出的平均评分低1个标准差。
  - Resolved 解决：前一天提取的相关谓词不被提取。

  



